// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               unknown
// source: rag/rag_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../google/protobuf/timestamp";

export const protobufPackage = "aura.rag";

export enum SearchDomain {
  SEARCH_DOMAIN_UNSPECIFIED = "SEARCH_DOMAIN_UNSPECIFIED",
  /** SEARCH_DOMAIN_MEETING - 회의 내용만 */
  SEARCH_DOMAIN_MEETING = "SEARCH_DOMAIN_MEETING",
  /** SEARCH_DOMAIN_DOCUMENTS - 업로드된 문서만 */
  SEARCH_DOMAIN_DOCUMENTS = "SEARCH_DOMAIN_DOCUMENTS",
  /** SEARCH_DOMAIN_WEB - 웹 검색 */
  SEARCH_DOMAIN_WEB = "SEARCH_DOMAIN_WEB",
  /** SEARCH_DOMAIN_ALL - 전체 */
  SEARCH_DOMAIN_ALL = "SEARCH_DOMAIN_ALL",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function searchDomainFromJSON(object: any): SearchDomain {
  switch (object) {
    case 0:
    case "SEARCH_DOMAIN_UNSPECIFIED":
      return SearchDomain.SEARCH_DOMAIN_UNSPECIFIED;
    case 1:
    case "SEARCH_DOMAIN_MEETING":
      return SearchDomain.SEARCH_DOMAIN_MEETING;
    case 2:
    case "SEARCH_DOMAIN_DOCUMENTS":
      return SearchDomain.SEARCH_DOMAIN_DOCUMENTS;
    case 3:
    case "SEARCH_DOMAIN_WEB":
      return SearchDomain.SEARCH_DOMAIN_WEB;
    case 4:
    case "SEARCH_DOMAIN_ALL":
      return SearchDomain.SEARCH_DOMAIN_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchDomain.UNRECOGNIZED;
  }
}

export function searchDomainToJSON(object: SearchDomain): string {
  switch (object) {
    case SearchDomain.SEARCH_DOMAIN_UNSPECIFIED:
      return "SEARCH_DOMAIN_UNSPECIFIED";
    case SearchDomain.SEARCH_DOMAIN_MEETING:
      return "SEARCH_DOMAIN_MEETING";
    case SearchDomain.SEARCH_DOMAIN_DOCUMENTS:
      return "SEARCH_DOMAIN_DOCUMENTS";
    case SearchDomain.SEARCH_DOMAIN_WEB:
      return "SEARCH_DOMAIN_WEB";
    case SearchDomain.SEARCH_DOMAIN_ALL:
      return "SEARCH_DOMAIN_ALL";
    case SearchDomain.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function searchDomainToNumber(object: SearchDomain): number {
  switch (object) {
    case SearchDomain.SEARCH_DOMAIN_UNSPECIFIED:
      return 0;
    case SearchDomain.SEARCH_DOMAIN_MEETING:
      return 1;
    case SearchDomain.SEARCH_DOMAIN_DOCUMENTS:
      return 2;
    case SearchDomain.SEARCH_DOMAIN_WEB:
      return 3;
    case SearchDomain.SEARCH_DOMAIN_ALL:
      return 4;
    case SearchDomain.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum DocumentType {
  DOCUMENT_TYPE_UNSPECIFIED = "DOCUMENT_TYPE_UNSPECIFIED",
  DOCUMENT_TYPE_PDF = "DOCUMENT_TYPE_PDF",
  DOCUMENT_TYPE_DOCX = "DOCUMENT_TYPE_DOCX",
  DOCUMENT_TYPE_TXT = "DOCUMENT_TYPE_TXT",
  DOCUMENT_TYPE_URL = "DOCUMENT_TYPE_URL",
  DOCUMENT_TYPE_MARKDOWN = "DOCUMENT_TYPE_MARKDOWN",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function documentTypeFromJSON(object: any): DocumentType {
  switch (object) {
    case 0:
    case "DOCUMENT_TYPE_UNSPECIFIED":
      return DocumentType.DOCUMENT_TYPE_UNSPECIFIED;
    case 1:
    case "DOCUMENT_TYPE_PDF":
      return DocumentType.DOCUMENT_TYPE_PDF;
    case 2:
    case "DOCUMENT_TYPE_DOCX":
      return DocumentType.DOCUMENT_TYPE_DOCX;
    case 3:
    case "DOCUMENT_TYPE_TXT":
      return DocumentType.DOCUMENT_TYPE_TXT;
    case 4:
    case "DOCUMENT_TYPE_URL":
      return DocumentType.DOCUMENT_TYPE_URL;
    case 5:
    case "DOCUMENT_TYPE_MARKDOWN":
      return DocumentType.DOCUMENT_TYPE_MARKDOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DocumentType.UNRECOGNIZED;
  }
}

export function documentTypeToJSON(object: DocumentType): string {
  switch (object) {
    case DocumentType.DOCUMENT_TYPE_UNSPECIFIED:
      return "DOCUMENT_TYPE_UNSPECIFIED";
    case DocumentType.DOCUMENT_TYPE_PDF:
      return "DOCUMENT_TYPE_PDF";
    case DocumentType.DOCUMENT_TYPE_DOCX:
      return "DOCUMENT_TYPE_DOCX";
    case DocumentType.DOCUMENT_TYPE_TXT:
      return "DOCUMENT_TYPE_TXT";
    case DocumentType.DOCUMENT_TYPE_URL:
      return "DOCUMENT_TYPE_URL";
    case DocumentType.DOCUMENT_TYPE_MARKDOWN:
      return "DOCUMENT_TYPE_MARKDOWN";
    case DocumentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function documentTypeToNumber(object: DocumentType): number {
  switch (object) {
    case DocumentType.DOCUMENT_TYPE_UNSPECIFIED:
      return 0;
    case DocumentType.DOCUMENT_TYPE_PDF:
      return 1;
    case DocumentType.DOCUMENT_TYPE_DOCX:
      return 2;
    case DocumentType.DOCUMENT_TYPE_TXT:
      return 3;
    case DocumentType.DOCUMENT_TYPE_URL:
      return 4;
    case DocumentType.DOCUMENT_TYPE_MARKDOWN:
      return 5;
    case DocumentType.UNRECOGNIZED:
    default:
      return -1;
  }
}

export enum ReportFormat {
  REPORT_FORMAT_UNSPECIFIED = "REPORT_FORMAT_UNSPECIFIED",
  REPORT_FORMAT_MARKDOWN = "REPORT_FORMAT_MARKDOWN",
  REPORT_FORMAT_HTML = "REPORT_FORMAT_HTML",
  REPORT_FORMAT_PDF = "REPORT_FORMAT_PDF",
  REPORT_FORMAT_JSON = "REPORT_FORMAT_JSON",
  UNRECOGNIZED = "UNRECOGNIZED",
}

export function reportFormatFromJSON(object: any): ReportFormat {
  switch (object) {
    case 0:
    case "REPORT_FORMAT_UNSPECIFIED":
      return ReportFormat.REPORT_FORMAT_UNSPECIFIED;
    case 1:
    case "REPORT_FORMAT_MARKDOWN":
      return ReportFormat.REPORT_FORMAT_MARKDOWN;
    case 2:
    case "REPORT_FORMAT_HTML":
      return ReportFormat.REPORT_FORMAT_HTML;
    case 3:
    case "REPORT_FORMAT_PDF":
      return ReportFormat.REPORT_FORMAT_PDF;
    case 4:
    case "REPORT_FORMAT_JSON":
      return ReportFormat.REPORT_FORMAT_JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReportFormat.UNRECOGNIZED;
  }
}

export function reportFormatToJSON(object: ReportFormat): string {
  switch (object) {
    case ReportFormat.REPORT_FORMAT_UNSPECIFIED:
      return "REPORT_FORMAT_UNSPECIFIED";
    case ReportFormat.REPORT_FORMAT_MARKDOWN:
      return "REPORT_FORMAT_MARKDOWN";
    case ReportFormat.REPORT_FORMAT_HTML:
      return "REPORT_FORMAT_HTML";
    case ReportFormat.REPORT_FORMAT_PDF:
      return "REPORT_FORMAT_PDF";
    case ReportFormat.REPORT_FORMAT_JSON:
      return "REPORT_FORMAT_JSON";
    case ReportFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export function reportFormatToNumber(object: ReportFormat): number {
  switch (object) {
    case ReportFormat.REPORT_FORMAT_UNSPECIFIED:
      return 0;
    case ReportFormat.REPORT_FORMAT_MARKDOWN:
      return 1;
    case ReportFormat.REPORT_FORMAT_HTML:
      return 2;
    case ReportFormat.REPORT_FORMAT_PDF:
      return 3;
    case ReportFormat.REPORT_FORMAT_JSON:
      return 4;
    case ReportFormat.UNRECOGNIZED:
    default:
      return -1;
  }
}

export interface PingRequest {
  clientId: string;
}

export interface PingResponse {
  alive: boolean;
  serverVersion: string;
  timestampMs: number;
}

export interface CreateSessionRequest {
  roomId: string;
  roomName: string;
  participants: string[];
  metadata: { [key: string]: string };
}

export interface CreateSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface CreateSessionResponse {
  success: boolean;
  sessionId: string;
  errorMessage: string;
}

export interface EndSessionRequest {
  roomId: string;
  generateReport: boolean;
}

export interface EndSessionResponse {
  success: boolean;
  reportUrl: string;
  errorMessage: string;
}

export interface QuestionRequest {
  roomId: string;
  question: string;
  userId: string;
  userName: string;
  searchDomain: SearchDomain;
  category: string;
}

export interface QuestionResponse {
  answer: string;
  searchResults: SearchResult[];
  confidence: number;
  latencyMs: number;
  requestId: string;
}

export interface SearchResult {
  title: string;
  snippet: string;
  url: string;
  source: string;
  relevanceScore: number;
  metadata: { [key: string]: string };
}

export interface SearchResult_MetadataEntry {
  key: string;
  value: string;
}

export interface StatementRequest {
  roomId: string;
  text: string;
  speakerId: string;
  speakerName: string;
  confidence: number;
  timestamp?: Date | undefined;
  isFinal: boolean;
}

export interface StatementResponse {
  success: boolean;
  statementId: string;
  errorMessage: string;
}

export interface DocumentRequest {
  roomId: string;
  fileName: string;
  fileContent: Uint8Array;
  /** file_content 대신 URL로 전달 가능 */
  fileUrl: string;
  fileType: DocumentType;
}

export interface DocumentResponse {
  success: boolean;
  documentId: string;
  chunkCount: number;
  errorMessage: string;
}

export interface ConversationMessage {
  roomId: string;
  requestId: string;
  question?: QuestionRequest | undefined;
  statement?: StatementRequest | undefined;
  prefetch?: PrefetchRequest | undefined;
}

export interface PrefetchRequest {
  roomId: string;
  /** 중간 텍스트로 미리 검색 */
  partialText: string;
}

export interface ConversationResponse {
  roomId: string;
  requestId: string;
  answer?: QuestionResponse | undefined;
  stored?: StatementResponse | undefined;
  prefetched?: PrefetchResponse | undefined;
  error?: ErrorResponse | undefined;
}

export interface PrefetchResponse {
  cachedResults: SearchResult[];
}

export interface ErrorResponse {
  errorCode: string;
  errorMessage: string;
}

export interface ReportRequest {
  roomId: string;
  format: ReportFormat;
  /** summary, transcripts, action_items 등 */
  includeSections: string[];
}

export interface ReportResponse {
  success: boolean;
  reportContent: string;
  reportUrl: string;
  summary?: MeetingSummary | undefined;
  errorMessage: string;
}

export interface MeetingSummary {
  title: string;
  durationMinutes: number;
  participantCount: number;
  keyTopics: string[];
  actionItems: ActionItem[];
  decisions: string[];
}

export interface ActionItem {
  description: string;
  assignee: string;
  dueDate: string;
  priority: string;
}

export interface MeetingContextRequest {
  roomId: string;
  /** 최근 N개 발언만 가져오기 */
  maxTranscripts: number;
}

export interface MeetingContextResponse {
  recentTranscripts: TranscriptEntry[];
  discussedTopics: string[];
  meetingTopic: string;
  totalStatements: number;
  totalQuestions: number;
}

export interface TranscriptEntry {
  speakerId: string;
  speakerName: string;
  text: string;
  timestamp?: Date | undefined;
}

function createBasePingRequest(): PingRequest {
  return { clientId: "" };
}

export const PingRequest: MessageFns<PingRequest> = {
  encode(message: PingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingRequest {
    return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
  },

  toJSON(message: PingRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingRequest>, I>>(base?: I): PingRequest {
    return PingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingRequest>, I>>(object: I): PingRequest {
    const message = createBasePingRequest();
    message.clientId = object.clientId ?? "";
    return message;
  },
};

function createBasePingResponse(): PingResponse {
  return { alive: false, serverVersion: "", timestampMs: 0 };
}

export const PingResponse: MessageFns<PingResponse> = {
  encode(message: PingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alive !== false) {
      writer.uint32(8).bool(message.alive);
    }
    if (message.serverVersion !== "") {
      writer.uint32(18).string(message.serverVersion);
    }
    if (message.timestampMs !== 0) {
      writer.uint32(24).int64(message.timestampMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.alive = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.serverVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestampMs = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingResponse {
    return {
      alive: isSet(object.alive) ? globalThis.Boolean(object.alive) : false,
      serverVersion: isSet(object.serverVersion) ? globalThis.String(object.serverVersion) : "",
      timestampMs: isSet(object.timestampMs) ? globalThis.Number(object.timestampMs) : 0,
    };
  },

  toJSON(message: PingResponse): unknown {
    const obj: any = {};
    if (message.alive !== false) {
      obj.alive = message.alive;
    }
    if (message.serverVersion !== "") {
      obj.serverVersion = message.serverVersion;
    }
    if (message.timestampMs !== 0) {
      obj.timestampMs = Math.round(message.timestampMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingResponse>, I>>(base?: I): PingResponse {
    return PingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingResponse>, I>>(object: I): PingResponse {
    const message = createBasePingResponse();
    message.alive = object.alive ?? false;
    message.serverVersion = object.serverVersion ?? "";
    message.timestampMs = object.timestampMs ?? 0;
    return message;
  },
};

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { roomId: "", roomName: "", participants: [], metadata: {} };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.roomName !== "") {
      writer.uint32(18).string(message.roomName);
    }
    for (const v of message.participants) {
      writer.uint32(26).string(v!);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      CreateSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participants.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CreateSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      roomName: isSet(object.roomName) ? globalThis.String(object.roomName) : "",
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => globalThis.String(e))
        : [],
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.participants?.length) {
      obj.participants = message.participants;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.roomId = object.roomId ?? "";
    message.roomName = object.roomName ?? "";
    message.participants = object.participants?.map((e) => e) || [];
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCreateSessionRequest_MetadataEntry(): CreateSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateSessionRequest_MetadataEntry: MessageFns<CreateSessionRequest_MetadataEntry> = {
  encode(message: CreateSessionRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSessionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest_MetadataEntry>, I>>(
    base?: I,
  ): CreateSessionRequest_MetadataEntry {
    return CreateSessionRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest_MetadataEntry>, I>>(
    object: I,
  ): CreateSessionRequest_MetadataEntry {
    const message = createBaseCreateSessionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { success: false, sessionId: "", errorMessage: "" };
}

export const CreateSessionResponse: MessageFns<CreateSessionResponse> = {
  encode(message: CreateSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(base?: I): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionResponse>, I>>(object: I): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.success = object.success ?? false;
    message.sessionId = object.sessionId ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseEndSessionRequest(): EndSessionRequest {
  return { roomId: "", generateReport: false };
}

export const EndSessionRequest: MessageFns<EndSessionRequest> = {
  encode(message: EndSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.generateReport !== false) {
      writer.uint32(16).bool(message.generateReport);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.generateReport = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndSessionRequest {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      generateReport: isSet(object.generateReport) ? globalThis.Boolean(object.generateReport) : false,
    };
  },

  toJSON(message: EndSessionRequest): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.generateReport !== false) {
      obj.generateReport = message.generateReport;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndSessionRequest>, I>>(base?: I): EndSessionRequest {
    return EndSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndSessionRequest>, I>>(object: I): EndSessionRequest {
    const message = createBaseEndSessionRequest();
    message.roomId = object.roomId ?? "";
    message.generateReport = object.generateReport ?? false;
    return message;
  },
};

function createBaseEndSessionResponse(): EndSessionResponse {
  return { success: false, reportUrl: "", errorMessage: "" };
}

export const EndSessionResponse: MessageFns<EndSessionResponse> = {
  encode(message: EndSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.reportUrl !== "") {
      writer.uint32(18).string(message.reportUrl);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reportUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndSessionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      reportUrl: isSet(object.reportUrl) ? globalThis.String(object.reportUrl) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: EndSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.reportUrl !== "") {
      obj.reportUrl = message.reportUrl;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndSessionResponse>, I>>(base?: I): EndSessionResponse {
    return EndSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndSessionResponse>, I>>(object: I): EndSessionResponse {
    const message = createBaseEndSessionResponse();
    message.success = object.success ?? false;
    message.reportUrl = object.reportUrl ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseQuestionRequest(): QuestionRequest {
  return {
    roomId: "",
    question: "",
    userId: "",
    userName: "",
    searchDomain: SearchDomain.SEARCH_DOMAIN_UNSPECIFIED,
    category: "",
  };
}

export const QuestionRequest: MessageFns<QuestionRequest> = {
  encode(message: QuestionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.question !== "") {
      writer.uint32(18).string(message.question);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.userName !== "") {
      writer.uint32(34).string(message.userName);
    }
    if (message.searchDomain !== SearchDomain.SEARCH_DOMAIN_UNSPECIFIED) {
      writer.uint32(40).int32(searchDomainToNumber(message.searchDomain));
    }
    if (message.category !== "") {
      writer.uint32(50).string(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.question = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.searchDomain = searchDomainFromJSON(reader.int32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.category = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionRequest {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      searchDomain: isSet(object.searchDomain)
        ? searchDomainFromJSON(object.searchDomain)
        : SearchDomain.SEARCH_DOMAIN_UNSPECIFIED,
      category: isSet(object.category) ? globalThis.String(object.category) : "",
    };
  },

  toJSON(message: QuestionRequest): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.searchDomain !== SearchDomain.SEARCH_DOMAIN_UNSPECIFIED) {
      obj.searchDomain = searchDomainToJSON(message.searchDomain);
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuestionRequest>, I>>(base?: I): QuestionRequest {
    return QuestionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuestionRequest>, I>>(object: I): QuestionRequest {
    const message = createBaseQuestionRequest();
    message.roomId = object.roomId ?? "";
    message.question = object.question ?? "";
    message.userId = object.userId ?? "";
    message.userName = object.userName ?? "";
    message.searchDomain = object.searchDomain ?? SearchDomain.SEARCH_DOMAIN_UNSPECIFIED;
    message.category = object.category ?? "";
    return message;
  },
};

function createBaseQuestionResponse(): QuestionResponse {
  return { answer: "", searchResults: [], confidence: 0, latencyMs: 0, requestId: "" };
}

export const QuestionResponse: MessageFns<QuestionResponse> = {
  encode(message: QuestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    for (const v of message.searchResults) {
      SearchResult.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(29).float(message.confidence);
    }
    if (message.latencyMs !== 0) {
      writer.uint32(32).int64(message.latencyMs);
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.searchResults.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.confidence = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.latencyMs = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuestionResponse {
    return {
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
      searchResults: globalThis.Array.isArray(object?.searchResults)
        ? object.searchResults.map((e: any) => SearchResult.fromJSON(e))
        : [],
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      latencyMs: isSet(object.latencyMs) ? globalThis.Number(object.latencyMs) : 0,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: QuestionResponse): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    if (message.searchResults?.length) {
      obj.searchResults = message.searchResults.map((e) => SearchResult.toJSON(e));
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.latencyMs !== 0) {
      obj.latencyMs = Math.round(message.latencyMs);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuestionResponse>, I>>(base?: I): QuestionResponse {
    return QuestionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuestionResponse>, I>>(object: I): QuestionResponse {
    const message = createBaseQuestionResponse();
    message.answer = object.answer ?? "";
    message.searchResults = object.searchResults?.map((e) => SearchResult.fromPartial(e)) || [];
    message.confidence = object.confidence ?? 0;
    message.latencyMs = object.latencyMs ?? 0;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return { title: "", snippet: "", url: "", source: "", relevanceScore: 0, metadata: {} };
}

export const SearchResult: MessageFns<SearchResult> = {
  encode(message: SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.snippet !== "") {
      writer.uint32(18).string(message.snippet);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    if (message.relevanceScore !== 0) {
      writer.uint32(45).float(message.relevanceScore);
    }
    globalThis.Object.entries(message.metadata).forEach(([key, value]: [string, string]) => {
      SearchResult_MetadataEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.snippet = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = SearchResult_MetadataEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.metadata[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      snippet: isSet(object.snippet) ? globalThis.String(object.snippet) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : 0,
      metadata: isObject(object.metadata)
        ? (globalThis.Object.entries(object.metadata) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.snippet !== "") {
      obj.snippet = message.snippet;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.relevanceScore !== 0) {
      obj.relevanceScore = message.relevanceScore;
    }
    if (message.metadata) {
      const entries = globalThis.Object.entries(message.metadata) as [string, string][];
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult>, I>>(base?: I): SearchResult {
    return SearchResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult>, I>>(object: I): SearchResult {
    const message = createBaseSearchResult();
    message.title = object.title ?? "";
    message.snippet = object.snippet ?? "";
    message.url = object.url ?? "";
    message.source = object.source ?? "";
    message.relevanceScore = object.relevanceScore ?? 0;
    message.metadata = (globalThis.Object.entries(object.metadata ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSearchResult_MetadataEntry(): SearchResult_MetadataEntry {
  return { key: "", value: "" };
}

export const SearchResult_MetadataEntry: MessageFns<SearchResult_MetadataEntry> = {
  encode(message: SearchResult_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SearchResult_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult_MetadataEntry>, I>>(base?: I): SearchResult_MetadataEntry {
    return SearchResult_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult_MetadataEntry>, I>>(object: I): SearchResult_MetadataEntry {
    const message = createBaseSearchResult_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStatementRequest(): StatementRequest {
  return { roomId: "", text: "", speakerId: "", speakerName: "", confidence: 0, timestamp: undefined, isFinal: false };
}

export const StatementRequest: MessageFns<StatementRequest> = {
  encode(message: StatementRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    if (message.speakerId !== "") {
      writer.uint32(26).string(message.speakerId);
    }
    if (message.speakerName !== "") {
      writer.uint32(34).string(message.speakerName);
    }
    if (message.confidence !== 0) {
      writer.uint32(45).float(message.confidence);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).join();
    }
    if (message.isFinal !== false) {
      writer.uint32(56).bool(message.isFinal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatementRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatementRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.speakerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.speakerName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.confidence = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isFinal = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatementRequest {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      speakerId: isSet(object.speakerId) ? globalThis.String(object.speakerId) : "",
      speakerName: isSet(object.speakerName) ? globalThis.String(object.speakerName) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      isFinal: isSet(object.isFinal) ? globalThis.Boolean(object.isFinal) : false,
    };
  },

  toJSON(message: StatementRequest): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.speakerId !== "") {
      obj.speakerId = message.speakerId;
    }
    if (message.speakerName !== "") {
      obj.speakerName = message.speakerName;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.isFinal !== false) {
      obj.isFinal = message.isFinal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatementRequest>, I>>(base?: I): StatementRequest {
    return StatementRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatementRequest>, I>>(object: I): StatementRequest {
    const message = createBaseStatementRequest();
    message.roomId = object.roomId ?? "";
    message.text = object.text ?? "";
    message.speakerId = object.speakerId ?? "";
    message.speakerName = object.speakerName ?? "";
    message.confidence = object.confidence ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.isFinal = object.isFinal ?? false;
    return message;
  },
};

function createBaseStatementResponse(): StatementResponse {
  return { success: false, statementId: "", errorMessage: "" };
}

export const StatementResponse: MessageFns<StatementResponse> = {
  encode(message: StatementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.statementId !== "") {
      writer.uint32(18).string(message.statementId);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statementId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatementResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      statementId: isSet(object.statementId) ? globalThis.String(object.statementId) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: StatementResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.statementId !== "") {
      obj.statementId = message.statementId;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatementResponse>, I>>(base?: I): StatementResponse {
    return StatementResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatementResponse>, I>>(object: I): StatementResponse {
    const message = createBaseStatementResponse();
    message.success = object.success ?? false;
    message.statementId = object.statementId ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseDocumentRequest(): DocumentRequest {
  return {
    roomId: "",
    fileName: "",
    fileContent: new Uint8Array(0),
    fileUrl: "",
    fileType: DocumentType.DOCUMENT_TYPE_UNSPECIFIED,
  };
}

export const DocumentRequest: MessageFns<DocumentRequest> = {
  encode(message: DocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.fileName !== "") {
      writer.uint32(18).string(message.fileName);
    }
    if (message.fileContent.length !== 0) {
      writer.uint32(26).bytes(message.fileContent);
    }
    if (message.fileUrl !== "") {
      writer.uint32(34).string(message.fileUrl);
    }
    if (message.fileType !== DocumentType.DOCUMENT_TYPE_UNSPECIFIED) {
      writer.uint32(40).int32(documentTypeToNumber(message.fileType));
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileContent = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.fileType = documentTypeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentRequest {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      fileName: isSet(object.fileName) ? globalThis.String(object.fileName) : "",
      fileContent: isSet(object.fileContent) ? bytesFromBase64(object.fileContent) : new Uint8Array(0),
      fileUrl: isSet(object.fileUrl) ? globalThis.String(object.fileUrl) : "",
      fileType: isSet(object.fileType) ? documentTypeFromJSON(object.fileType) : DocumentType.DOCUMENT_TYPE_UNSPECIFIED,
    };
  },

  toJSON(message: DocumentRequest): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.fileName !== "") {
      obj.fileName = message.fileName;
    }
    if (message.fileContent.length !== 0) {
      obj.fileContent = base64FromBytes(message.fileContent);
    }
    if (message.fileUrl !== "") {
      obj.fileUrl = message.fileUrl;
    }
    if (message.fileType !== DocumentType.DOCUMENT_TYPE_UNSPECIFIED) {
      obj.fileType = documentTypeToJSON(message.fileType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentRequest>, I>>(base?: I): DocumentRequest {
    return DocumentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentRequest>, I>>(object: I): DocumentRequest {
    const message = createBaseDocumentRequest();
    message.roomId = object.roomId ?? "";
    message.fileName = object.fileName ?? "";
    message.fileContent = object.fileContent ?? new Uint8Array(0);
    message.fileUrl = object.fileUrl ?? "";
    message.fileType = object.fileType ?? DocumentType.DOCUMENT_TYPE_UNSPECIFIED;
    return message;
  },
};

function createBaseDocumentResponse(): DocumentResponse {
  return { success: false, documentId: "", chunkCount: 0, errorMessage: "" };
}

export const DocumentResponse: MessageFns<DocumentResponse> = {
  encode(message: DocumentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.documentId !== "") {
      writer.uint32(18).string(message.documentId);
    }
    if (message.chunkCount !== 0) {
      writer.uint32(24).int32(message.chunkCount);
    }
    if (message.errorMessage !== "") {
      writer.uint32(34).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.documentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.chunkCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      documentId: isSet(object.documentId) ? globalThis.String(object.documentId) : "",
      chunkCount: isSet(object.chunkCount) ? globalThis.Number(object.chunkCount) : 0,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: DocumentResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.documentId !== "") {
      obj.documentId = message.documentId;
    }
    if (message.chunkCount !== 0) {
      obj.chunkCount = Math.round(message.chunkCount);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DocumentResponse>, I>>(base?: I): DocumentResponse {
    return DocumentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DocumentResponse>, I>>(object: I): DocumentResponse {
    const message = createBaseDocumentResponse();
    message.success = object.success ?? false;
    message.documentId = object.documentId ?? "";
    message.chunkCount = object.chunkCount ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseConversationMessage(): ConversationMessage {
  return { roomId: "", requestId: "", question: undefined, statement: undefined, prefetch: undefined };
}

export const ConversationMessage: MessageFns<ConversationMessage> = {
  encode(message: ConversationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.question !== undefined) {
      QuestionRequest.encode(message.question, writer.uint32(26).fork()).join();
    }
    if (message.statement !== undefined) {
      StatementRequest.encode(message.statement, writer.uint32(34).fork()).join();
    }
    if (message.prefetch !== undefined) {
      PrefetchRequest.encode(message.prefetch, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.question = QuestionRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.statement = StatementRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prefetch = PrefetchRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationMessage {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      question: isSet(object.question) ? QuestionRequest.fromJSON(object.question) : undefined,
      statement: isSet(object.statement) ? StatementRequest.fromJSON(object.statement) : undefined,
      prefetch: isSet(object.prefetch) ? PrefetchRequest.fromJSON(object.prefetch) : undefined,
    };
  },

  toJSON(message: ConversationMessage): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.question !== undefined) {
      obj.question = QuestionRequest.toJSON(message.question);
    }
    if (message.statement !== undefined) {
      obj.statement = StatementRequest.toJSON(message.statement);
    }
    if (message.prefetch !== undefined) {
      obj.prefetch = PrefetchRequest.toJSON(message.prefetch);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationMessage>, I>>(base?: I): ConversationMessage {
    return ConversationMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationMessage>, I>>(object: I): ConversationMessage {
    const message = createBaseConversationMessage();
    message.roomId = object.roomId ?? "";
    message.requestId = object.requestId ?? "";
    message.question = (object.question !== undefined && object.question !== null)
      ? QuestionRequest.fromPartial(object.question)
      : undefined;
    message.statement = (object.statement !== undefined && object.statement !== null)
      ? StatementRequest.fromPartial(object.statement)
      : undefined;
    message.prefetch = (object.prefetch !== undefined && object.prefetch !== null)
      ? PrefetchRequest.fromPartial(object.prefetch)
      : undefined;
    return message;
  },
};

function createBasePrefetchRequest(): PrefetchRequest {
  return { roomId: "", partialText: "" };
}

export const PrefetchRequest: MessageFns<PrefetchRequest> = {
  encode(message: PrefetchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.partialText !== "") {
      writer.uint32(18).string(message.partialText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrefetchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrefetchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partialText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrefetchRequest {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      partialText: isSet(object.partialText) ? globalThis.String(object.partialText) : "",
    };
  },

  toJSON(message: PrefetchRequest): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.partialText !== "") {
      obj.partialText = message.partialText;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrefetchRequest>, I>>(base?: I): PrefetchRequest {
    return PrefetchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrefetchRequest>, I>>(object: I): PrefetchRequest {
    const message = createBasePrefetchRequest();
    message.roomId = object.roomId ?? "";
    message.partialText = object.partialText ?? "";
    return message;
  },
};

function createBaseConversationResponse(): ConversationResponse {
  return { roomId: "", requestId: "", answer: undefined, stored: undefined, prefetched: undefined, error: undefined };
}

export const ConversationResponse: MessageFns<ConversationResponse> = {
  encode(message: ConversationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.answer !== undefined) {
      QuestionResponse.encode(message.answer, writer.uint32(26).fork()).join();
    }
    if (message.stored !== undefined) {
      StatementResponse.encode(message.stored, writer.uint32(34).fork()).join();
    }
    if (message.prefetched !== undefined) {
      PrefetchResponse.encode(message.prefetched, writer.uint32(42).fork()).join();
    }
    if (message.error !== undefined) {
      ErrorResponse.encode(message.error, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.answer = QuestionResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stored = StatementResponse.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prefetched = PrefetchResponse.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = ErrorResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationResponse {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      answer: isSet(object.answer) ? QuestionResponse.fromJSON(object.answer) : undefined,
      stored: isSet(object.stored) ? StatementResponse.fromJSON(object.stored) : undefined,
      prefetched: isSet(object.prefetched) ? PrefetchResponse.fromJSON(object.prefetched) : undefined,
      error: isSet(object.error) ? ErrorResponse.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ConversationResponse): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.answer !== undefined) {
      obj.answer = QuestionResponse.toJSON(message.answer);
    }
    if (message.stored !== undefined) {
      obj.stored = StatementResponse.toJSON(message.stored);
    }
    if (message.prefetched !== undefined) {
      obj.prefetched = PrefetchResponse.toJSON(message.prefetched);
    }
    if (message.error !== undefined) {
      obj.error = ErrorResponse.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationResponse>, I>>(base?: I): ConversationResponse {
    return ConversationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationResponse>, I>>(object: I): ConversationResponse {
    const message = createBaseConversationResponse();
    message.roomId = object.roomId ?? "";
    message.requestId = object.requestId ?? "";
    message.answer = (object.answer !== undefined && object.answer !== null)
      ? QuestionResponse.fromPartial(object.answer)
      : undefined;
    message.stored = (object.stored !== undefined && object.stored !== null)
      ? StatementResponse.fromPartial(object.stored)
      : undefined;
    message.prefetched = (object.prefetched !== undefined && object.prefetched !== null)
      ? PrefetchResponse.fromPartial(object.prefetched)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorResponse.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBasePrefetchResponse(): PrefetchResponse {
  return { cachedResults: [] };
}

export const PrefetchResponse: MessageFns<PrefetchResponse> = {
  encode(message: PrefetchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cachedResults) {
      SearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrefetchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrefetchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cachedResults.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrefetchResponse {
    return {
      cachedResults: globalThis.Array.isArray(object?.cachedResults)
        ? object.cachedResults.map((e: any) => SearchResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PrefetchResponse): unknown {
    const obj: any = {};
    if (message.cachedResults?.length) {
      obj.cachedResults = message.cachedResults.map((e) => SearchResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrefetchResponse>, I>>(base?: I): PrefetchResponse {
    return PrefetchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrefetchResponse>, I>>(object: I): PrefetchResponse {
    const message = createBasePrefetchResponse();
    message.cachedResults = object.cachedResults?.map((e) => SearchResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorResponse(): ErrorResponse {
  return { errorCode: "", errorMessage: "" };
}

export const ErrorResponse: MessageFns<ErrorResponse> = {
  encode(message: ErrorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorResponse {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: ErrorResponse): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorResponse>, I>>(base?: I): ErrorResponse {
    return ErrorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorResponse>, I>>(object: I): ErrorResponse {
    const message = createBaseErrorResponse();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseReportRequest(): ReportRequest {
  return { roomId: "", format: ReportFormat.REPORT_FORMAT_UNSPECIFIED, includeSections: [] };
}

export const ReportRequest: MessageFns<ReportRequest> = {
  encode(message: ReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.format !== ReportFormat.REPORT_FORMAT_UNSPECIFIED) {
      writer.uint32(16).int32(reportFormatToNumber(message.format));
    }
    for (const v of message.includeSections) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.format = reportFormatFromJSON(reader.int32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.includeSections.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportRequest {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      format: isSet(object.format) ? reportFormatFromJSON(object.format) : ReportFormat.REPORT_FORMAT_UNSPECIFIED,
      includeSections: globalThis.Array.isArray(object?.includeSections)
        ? object.includeSections.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ReportRequest): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.format !== ReportFormat.REPORT_FORMAT_UNSPECIFIED) {
      obj.format = reportFormatToJSON(message.format);
    }
    if (message.includeSections?.length) {
      obj.includeSections = message.includeSections;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReportRequest>, I>>(base?: I): ReportRequest {
    return ReportRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReportRequest>, I>>(object: I): ReportRequest {
    const message = createBaseReportRequest();
    message.roomId = object.roomId ?? "";
    message.format = object.format ?? ReportFormat.REPORT_FORMAT_UNSPECIFIED;
    message.includeSections = object.includeSections?.map((e) => e) || [];
    return message;
  },
};

function createBaseReportResponse(): ReportResponse {
  return { success: false, reportContent: "", reportUrl: "", summary: undefined, errorMessage: "" };
}

export const ReportResponse: MessageFns<ReportResponse> = {
  encode(message: ReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.reportContent !== "") {
      writer.uint32(18).string(message.reportContent);
    }
    if (message.reportUrl !== "") {
      writer.uint32(26).string(message.reportUrl);
    }
    if (message.summary !== undefined) {
      MeetingSummary.encode(message.summary, writer.uint32(34).fork()).join();
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reportContent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reportUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.summary = MeetingSummary.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      reportContent: isSet(object.reportContent) ? globalThis.String(object.reportContent) : "",
      reportUrl: isSet(object.reportUrl) ? globalThis.String(object.reportUrl) : "",
      summary: isSet(object.summary) ? MeetingSummary.fromJSON(object.summary) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: ReportResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.reportContent !== "") {
      obj.reportContent = message.reportContent;
    }
    if (message.reportUrl !== "") {
      obj.reportUrl = message.reportUrl;
    }
    if (message.summary !== undefined) {
      obj.summary = MeetingSummary.toJSON(message.summary);
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReportResponse>, I>>(base?: I): ReportResponse {
    return ReportResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReportResponse>, I>>(object: I): ReportResponse {
    const message = createBaseReportResponse();
    message.success = object.success ?? false;
    message.reportContent = object.reportContent ?? "";
    message.reportUrl = object.reportUrl ?? "";
    message.summary = (object.summary !== undefined && object.summary !== null)
      ? MeetingSummary.fromPartial(object.summary)
      : undefined;
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseMeetingSummary(): MeetingSummary {
  return { title: "", durationMinutes: 0, participantCount: 0, keyTopics: [], actionItems: [], decisions: [] };
}

export const MeetingSummary: MessageFns<MeetingSummary> = {
  encode(message: MeetingSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.durationMinutes !== 0) {
      writer.uint32(16).int32(message.durationMinutes);
    }
    if (message.participantCount !== 0) {
      writer.uint32(24).int32(message.participantCount);
    }
    for (const v of message.keyTopics) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.actionItems) {
      ActionItem.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.decisions) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MeetingSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeetingSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.durationMinutes = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.participantCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keyTopics.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.actionItems.push(ActionItem.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.decisions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MeetingSummary {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      durationMinutes: isSet(object.durationMinutes) ? globalThis.Number(object.durationMinutes) : 0,
      participantCount: isSet(object.participantCount) ? globalThis.Number(object.participantCount) : 0,
      keyTopics: globalThis.Array.isArray(object?.keyTopics)
        ? object.keyTopics.map((e: any) => globalThis.String(e))
        : [],
      actionItems: globalThis.Array.isArray(object?.actionItems)
        ? object.actionItems.map((e: any) => ActionItem.fromJSON(e))
        : [],
      decisions: globalThis.Array.isArray(object?.decisions)
        ? object.decisions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MeetingSummary): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.durationMinutes !== 0) {
      obj.durationMinutes = Math.round(message.durationMinutes);
    }
    if (message.participantCount !== 0) {
      obj.participantCount = Math.round(message.participantCount);
    }
    if (message.keyTopics?.length) {
      obj.keyTopics = message.keyTopics;
    }
    if (message.actionItems?.length) {
      obj.actionItems = message.actionItems.map((e) => ActionItem.toJSON(e));
    }
    if (message.decisions?.length) {
      obj.decisions = message.decisions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MeetingSummary>, I>>(base?: I): MeetingSummary {
    return MeetingSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MeetingSummary>, I>>(object: I): MeetingSummary {
    const message = createBaseMeetingSummary();
    message.title = object.title ?? "";
    message.durationMinutes = object.durationMinutes ?? 0;
    message.participantCount = object.participantCount ?? 0;
    message.keyTopics = object.keyTopics?.map((e) => e) || [];
    message.actionItems = object.actionItems?.map((e) => ActionItem.fromPartial(e)) || [];
    message.decisions = object.decisions?.map((e) => e) || [];
    return message;
  },
};

function createBaseActionItem(): ActionItem {
  return { description: "", assignee: "", dueDate: "", priority: "" };
}

export const ActionItem: MessageFns<ActionItem> = {
  encode(message: ActionItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.assignee !== "") {
      writer.uint32(18).string(message.assignee);
    }
    if (message.dueDate !== "") {
      writer.uint32(26).string(message.dueDate);
    }
    if (message.priority !== "") {
      writer.uint32(34).string(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assignee = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dueDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.priority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionItem {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      assignee: isSet(object.assignee) ? globalThis.String(object.assignee) : "",
      dueDate: isSet(object.dueDate) ? globalThis.String(object.dueDate) : "",
      priority: isSet(object.priority) ? globalThis.String(object.priority) : "",
    };
  },

  toJSON(message: ActionItem): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.assignee !== "") {
      obj.assignee = message.assignee;
    }
    if (message.dueDate !== "") {
      obj.dueDate = message.dueDate;
    }
    if (message.priority !== "") {
      obj.priority = message.priority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionItem>, I>>(base?: I): ActionItem {
    return ActionItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionItem>, I>>(object: I): ActionItem {
    const message = createBaseActionItem();
    message.description = object.description ?? "";
    message.assignee = object.assignee ?? "";
    message.dueDate = object.dueDate ?? "";
    message.priority = object.priority ?? "";
    return message;
  },
};

function createBaseMeetingContextRequest(): MeetingContextRequest {
  return { roomId: "", maxTranscripts: 0 };
}

export const MeetingContextRequest: MessageFns<MeetingContextRequest> = {
  encode(message: MeetingContextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomId !== "") {
      writer.uint32(10).string(message.roomId);
    }
    if (message.maxTranscripts !== 0) {
      writer.uint32(16).int32(message.maxTranscripts);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MeetingContextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeetingContextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxTranscripts = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MeetingContextRequest {
    return {
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      maxTranscripts: isSet(object.maxTranscripts) ? globalThis.Number(object.maxTranscripts) : 0,
    };
  },

  toJSON(message: MeetingContextRequest): unknown {
    const obj: any = {};
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.maxTranscripts !== 0) {
      obj.maxTranscripts = Math.round(message.maxTranscripts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MeetingContextRequest>, I>>(base?: I): MeetingContextRequest {
    return MeetingContextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MeetingContextRequest>, I>>(object: I): MeetingContextRequest {
    const message = createBaseMeetingContextRequest();
    message.roomId = object.roomId ?? "";
    message.maxTranscripts = object.maxTranscripts ?? 0;
    return message;
  },
};

function createBaseMeetingContextResponse(): MeetingContextResponse {
  return { recentTranscripts: [], discussedTopics: [], meetingTopic: "", totalStatements: 0, totalQuestions: 0 };
}

export const MeetingContextResponse: MessageFns<MeetingContextResponse> = {
  encode(message: MeetingContextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recentTranscripts) {
      TranscriptEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.discussedTopics) {
      writer.uint32(18).string(v!);
    }
    if (message.meetingTopic !== "") {
      writer.uint32(26).string(message.meetingTopic);
    }
    if (message.totalStatements !== 0) {
      writer.uint32(32).int32(message.totalStatements);
    }
    if (message.totalQuestions !== 0) {
      writer.uint32(40).int32(message.totalQuestions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MeetingContextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeetingContextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recentTranscripts.push(TranscriptEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.discussedTopics.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.meetingTopic = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalStatements = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalQuestions = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MeetingContextResponse {
    return {
      recentTranscripts: globalThis.Array.isArray(object?.recentTranscripts)
        ? object.recentTranscripts.map((e: any) => TranscriptEntry.fromJSON(e))
        : [],
      discussedTopics: globalThis.Array.isArray(object?.discussedTopics)
        ? object.discussedTopics.map((e: any) => globalThis.String(e))
        : [],
      meetingTopic: isSet(object.meetingTopic) ? globalThis.String(object.meetingTopic) : "",
      totalStatements: isSet(object.totalStatements) ? globalThis.Number(object.totalStatements) : 0,
      totalQuestions: isSet(object.totalQuestions) ? globalThis.Number(object.totalQuestions) : 0,
    };
  },

  toJSON(message: MeetingContextResponse): unknown {
    const obj: any = {};
    if (message.recentTranscripts?.length) {
      obj.recentTranscripts = message.recentTranscripts.map((e) => TranscriptEntry.toJSON(e));
    }
    if (message.discussedTopics?.length) {
      obj.discussedTopics = message.discussedTopics;
    }
    if (message.meetingTopic !== "") {
      obj.meetingTopic = message.meetingTopic;
    }
    if (message.totalStatements !== 0) {
      obj.totalStatements = Math.round(message.totalStatements);
    }
    if (message.totalQuestions !== 0) {
      obj.totalQuestions = Math.round(message.totalQuestions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MeetingContextResponse>, I>>(base?: I): MeetingContextResponse {
    return MeetingContextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MeetingContextResponse>, I>>(object: I): MeetingContextResponse {
    const message = createBaseMeetingContextResponse();
    message.recentTranscripts = object.recentTranscripts?.map((e) => TranscriptEntry.fromPartial(e)) || [];
    message.discussedTopics = object.discussedTopics?.map((e) => e) || [];
    message.meetingTopic = object.meetingTopic ?? "";
    message.totalStatements = object.totalStatements ?? 0;
    message.totalQuestions = object.totalQuestions ?? 0;
    return message;
  },
};

function createBaseTranscriptEntry(): TranscriptEntry {
  return { speakerId: "", speakerName: "", text: "", timestamp: undefined };
}

export const TranscriptEntry: MessageFns<TranscriptEntry> = {
  encode(message: TranscriptEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.speakerId !== "") {
      writer.uint32(10).string(message.speakerId);
    }
    if (message.speakerName !== "") {
      writer.uint32(18).string(message.speakerName);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TranscriptEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.speakerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.speakerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptEntry {
    return {
      speakerId: isSet(object.speakerId) ? globalThis.String(object.speakerId) : "",
      speakerName: isSet(object.speakerName) ? globalThis.String(object.speakerName) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: TranscriptEntry): unknown {
    const obj: any = {};
    if (message.speakerId !== "") {
      obj.speakerId = message.speakerId;
    }
    if (message.speakerName !== "") {
      obj.speakerName = message.speakerName;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TranscriptEntry>, I>>(base?: I): TranscriptEntry {
    return TranscriptEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TranscriptEntry>, I>>(object: I): TranscriptEntry {
    const message = createBaseTranscriptEntry();
    message.speakerId = object.speakerId ?? "";
    message.speakerName = object.speakerName ?? "";
    message.text = object.text ?? "";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

export type RagServiceService = typeof RagServiceService;
export const RagServiceService = {
  /** Health Check */
  ping: {
    path: "/aura.rag.RagService/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: PingRequest): Buffer => Buffer.from(PingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): PingRequest => PingRequest.decode(value),
    responseSerialize: (value: PingResponse): Buffer => Buffer.from(PingResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): PingResponse => PingResponse.decode(value),
  },
  /** 세션 관리 */
  createSession: {
    path: "/aura.rag.RagService/CreateSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSessionRequest): Buffer => Buffer.from(CreateSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSessionRequest => CreateSessionRequest.decode(value),
    responseSerialize: (value: CreateSessionResponse): Buffer =>
      Buffer.from(CreateSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateSessionResponse => CreateSessionResponse.decode(value),
  },
  endSession: {
    path: "/aura.rag.RagService/EndSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: EndSessionRequest): Buffer => Buffer.from(EndSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): EndSessionRequest => EndSessionRequest.decode(value),
    responseSerialize: (value: EndSessionResponse): Buffer => Buffer.from(EndSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): EndSessionResponse => EndSessionResponse.decode(value),
  },
  /** 단일 요청-응답 (Unary RPC) */
  askQuestion: {
    path: "/aura.rag.RagService/AskQuestion",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: QuestionRequest): Buffer => Buffer.from(QuestionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): QuestionRequest => QuestionRequest.decode(value),
    responseSerialize: (value: QuestionResponse): Buffer => Buffer.from(QuestionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): QuestionResponse => QuestionResponse.decode(value),
  },
  storeStatement: {
    path: "/aura.rag.RagService/StoreStatement",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: StatementRequest): Buffer => Buffer.from(StatementRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StatementRequest => StatementRequest.decode(value),
    responseSerialize: (value: StatementResponse): Buffer => Buffer.from(StatementResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StatementResponse => StatementResponse.decode(value),
  },
  processDocument: {
    path: "/aura.rag.RagService/ProcessDocument",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DocumentRequest): Buffer => Buffer.from(DocumentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DocumentRequest => DocumentRequest.decode(value),
    responseSerialize: (value: DocumentResponse): Buffer => Buffer.from(DocumentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DocumentResponse => DocumentResponse.decode(value),
  },
  /** 양방향 스트리밍 (Bidirectional Streaming) */
  streamConversation: {
    path: "/aura.rag.RagService/StreamConversation",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ConversationMessage): Buffer => Buffer.from(ConversationMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer): ConversationMessage => ConversationMessage.decode(value),
    responseSerialize: (value: ConversationResponse): Buffer =>
      Buffer.from(ConversationResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConversationResponse => ConversationResponse.decode(value),
  },
  /** 회의 관련 */
  generateReport: {
    path: "/aura.rag.RagService/GenerateReport",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReportRequest): Buffer => Buffer.from(ReportRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ReportRequest => ReportRequest.decode(value),
    responseSerialize: (value: ReportResponse): Buffer => Buffer.from(ReportResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ReportResponse => ReportResponse.decode(value),
  },
  getMeetingContext: {
    path: "/aura.rag.RagService/GetMeetingContext",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MeetingContextRequest): Buffer =>
      Buffer.from(MeetingContextRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): MeetingContextRequest => MeetingContextRequest.decode(value),
    responseSerialize: (value: MeetingContextResponse): Buffer =>
      Buffer.from(MeetingContextResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): MeetingContextResponse => MeetingContextResponse.decode(value),
  },
} as const;

export interface RagServiceServer extends UntypedServiceImplementation {
  /** Health Check */
  ping: handleUnaryCall<PingRequest, PingResponse>;
  /** 세션 관리 */
  createSession: handleUnaryCall<CreateSessionRequest, CreateSessionResponse>;
  endSession: handleUnaryCall<EndSessionRequest, EndSessionResponse>;
  /** 단일 요청-응답 (Unary RPC) */
  askQuestion: handleUnaryCall<QuestionRequest, QuestionResponse>;
  storeStatement: handleUnaryCall<StatementRequest, StatementResponse>;
  processDocument: handleUnaryCall<DocumentRequest, DocumentResponse>;
  /** 양방향 스트리밍 (Bidirectional Streaming) */
  streamConversation: handleBidiStreamingCall<ConversationMessage, ConversationResponse>;
  /** 회의 관련 */
  generateReport: handleUnaryCall<ReportRequest, ReportResponse>;
  getMeetingContext: handleUnaryCall<MeetingContextRequest, MeetingContextResponse>;
}

export interface RagServiceClient extends Client {
  /** Health Check */
  ping(request: PingRequest, callback: (error: ServiceError | null, response: PingResponse) => void): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
  ping(
    request: PingRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PingResponse) => void,
  ): ClientUnaryCall;
  /** 세션 관리 */
  createSession(
    request: CreateSessionRequest,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  endSession(
    request: EndSessionRequest,
    callback: (error: ServiceError | null, response: EndSessionResponse) => void,
  ): ClientUnaryCall;
  endSession(
    request: EndSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: EndSessionResponse) => void,
  ): ClientUnaryCall;
  endSession(
    request: EndSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: EndSessionResponse) => void,
  ): ClientUnaryCall;
  /** 단일 요청-응답 (Unary RPC) */
  askQuestion(
    request: QuestionRequest,
    callback: (error: ServiceError | null, response: QuestionResponse) => void,
  ): ClientUnaryCall;
  askQuestion(
    request: QuestionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: QuestionResponse) => void,
  ): ClientUnaryCall;
  askQuestion(
    request: QuestionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: QuestionResponse) => void,
  ): ClientUnaryCall;
  storeStatement(
    request: StatementRequest,
    callback: (error: ServiceError | null, response: StatementResponse) => void,
  ): ClientUnaryCall;
  storeStatement(
    request: StatementRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: StatementResponse) => void,
  ): ClientUnaryCall;
  storeStatement(
    request: StatementRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: StatementResponse) => void,
  ): ClientUnaryCall;
  processDocument(
    request: DocumentRequest,
    callback: (error: ServiceError | null, response: DocumentResponse) => void,
  ): ClientUnaryCall;
  processDocument(
    request: DocumentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DocumentResponse) => void,
  ): ClientUnaryCall;
  processDocument(
    request: DocumentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DocumentResponse) => void,
  ): ClientUnaryCall;
  /** 양방향 스트리밍 (Bidirectional Streaming) */
  streamConversation(): ClientDuplexStream<ConversationMessage, ConversationResponse>;
  streamConversation(options: Partial<CallOptions>): ClientDuplexStream<ConversationMessage, ConversationResponse>;
  streamConversation(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ConversationMessage, ConversationResponse>;
  /** 회의 관련 */
  generateReport(
    request: ReportRequest,
    callback: (error: ServiceError | null, response: ReportResponse) => void,
  ): ClientUnaryCall;
  generateReport(
    request: ReportRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReportResponse) => void,
  ): ClientUnaryCall;
  generateReport(
    request: ReportRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReportResponse) => void,
  ): ClientUnaryCall;
  getMeetingContext(
    request: MeetingContextRequest,
    callback: (error: ServiceError | null, response: MeetingContextResponse) => void,
  ): ClientUnaryCall;
  getMeetingContext(
    request: MeetingContextRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MeetingContextResponse) => void,
  ): ClientUnaryCall;
  getMeetingContext(
    request: MeetingContextRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MeetingContextResponse) => void,
  ): ClientUnaryCall;
}

export const RagServiceClient = makeGenericClientConstructor(RagServiceService, "aura.rag.RagService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): RagServiceClient;
  service: typeof RagServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
